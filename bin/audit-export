#!/usr/bin/env python3
"""
CLI wrapper to run `AuditExporter` batches.

Reads configuration from command-line flags or environment variables:

ENV / flag            default
-------------------   ------------------
DATABASE_URL          --db-url (required if env missing)
AUDIT_EXPORT_DIR      ./audit_exports
AUDIT_EXPORT_BATCH    5000
AUDIT_EXPORT_LAG_MIN  5

Example:
    bin/audit-export --db-url $DATABASE_URL --out-dir /mnt/exports

Exit code 0 on success, non-zero on error.
"""
from __future__ import annotations

import argparse
import os
import sys
from pathlib import Path

# Ensure project root is on sys.path
ROOT = Path(__file__).resolve().parents[1]
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))

# Best-effort SA/dateutil compatibility shim (used elsewhere in the repo)
try:
    from credit_facility.sa_compat import apply as _apply_sa_compat
except Exception as exc:  # pragma: no cover
    print(f"warning: couldn't import sa_compat apply(): {exc}", file=sys.stderr)
else:
    _apply_sa_compat()

from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from sqlmodel import Session as SQLSession

# Import exporter from credit_facility
try:
    from credit_facility.audit_exporter import AuditExporter
except ImportError as exc:
    print(f"error: cannot import AuditExporter – {exc}", file=sys.stderr)
    sys.exit(2)


def parse_args() -> argparse.Namespace:
    ap = argparse.ArgumentParser(description="Run audit exporter batches")
    ap.add_argument("--db-url", default=os.getenv("DATABASE_URL"), help="SQLAlchemy database URL")
    ap.add_argument("--out-dir", default=os.getenv("AUDIT_EXPORT_DIR", "./audit_exports"))
    ap.add_argument("--batch-size", type=int, default=int(os.getenv("AUDIT_EXPORT_BATCH", 5000)))
    ap.add_argument("--cutoff-lag-min", type=int, default=int(os.getenv("AUDIT_EXPORT_LAG_MIN", 5)))
    ap.add_argument("--max-batches", type=int, default=None)
    ap.add_argument("--dry-run", action="store_true")
    return ap.parse_args()


def _build_engine(db_url: str):
    """
    Create a SQLAlchemy engine with SQLite-friendly datetime parsing.

    On SQLite, we register a tolerant converter so date-only strings like
    'YYYY-MM-DD' (with or without surrounding quotes), and other common variants,
    won't crash fetch operations.
    """
    if db_url.startswith("sqlite:"):
        import sqlite3
        from datetime import datetime, date

        def _tolerant_parse(s: str):
            # Accepts:
            # - 'YYYY-MM-DD' (optionally wrapped in single/double quotes)
            # - 'YYYY-MM-DD HH:MM:SS[.fff][Z]'
            # - ISO8601 with 'T' or space, with/without 'Z' or timezone
            if s is None:
                raise ValueError("empty datetime")
            s = str(s).strip()
            if not s:
                raise ValueError("empty datetime")

            # Strip a single pair of surrounding quotes if present
            if (s.startswith("'") and s.endswith("'")) or (s.startswith('"') and s.endswith('"')):
                s = s[1:-1].strip()

            # Normalize 'Z' to '+00:00'
            if s.endswith("Z"):
                s = s[:-1] + "+00:00"

            # If there's a space instead of 'T', normalize (first occurrence only)
            if " " in s and "T" not in s:
                s = s.replace(" ", "T", 1)

            # Try datetime.fromisoformat first
            try:
                return datetime.fromisoformat(s)
            except ValueError:
                # Handle pure date (YYYY-MM-DD)
                if len(s) == 10 and s.count("-") == 2:
                    d = date.fromisoformat(s)
                    return datetime.combine(d, datetime.min.time())
                # Last resort: dateutil (if available)
                try:
                    from dateutil import parser as dp  # type: ignore
                    return dp.parse(s)
                except Exception as e:
                    raise ValueError(f"Couldn't parse datetime string: '{s}'") from e

        def _conv_bytes_to_dt(b):
            # SQLite passes bytes to converters
            s = b.decode("utf-8") if isinstance(b, (bytes, bytearray)) else str(b)
            return _tolerant_parse(s)

        # Register converters for common datetime affinities in SQLite
        sqlite3.register_converter("TIMESTAMP", _conv_bytes_to_dt)
        sqlite3.register_converter("DATETIME", _conv_bytes_to_dt)
        sqlite3.register_converter("DATE", _conv_bytes_to_dt)

        detect = sqlite3.PARSE_DECLTYPES | sqlite3.PARSE_COLNAMES
        return create_engine(
            db_url,
            future=True,
            pool_pre_ping=True,
            connect_args={"detect_types": detect},
        )

    # Non-SQLite engines (e.g., Postgres)
    return create_engine(db_url, pool_pre_ping=True, future=True)


def main() -> None:
    args = parse_args()
    if not args.db_url:
        print("error: --db-url or $DATABASE_URL required", file=sys.stderr)
        sys.exit(2)

    engine = _build_engine(args.db_url)
    sf = sessionmaker(
        engine,
        class_=SQLSession,
        autoflush=False,
        expire_on_commit=False,
        future=True,
    )

    exporter = AuditExporter(
        session_factory=sf,
        out_dir=Path(args.out_dir),
        batch_size=args.batch_size,
        cutoff_seconds=args.cutoff_lag_min * 60,
    )

    try:
        stats = exporter.run_until_empty(
            max_batches=args.max_batches,
            dry_run=args.dry_run,
        )
        print(stats)
    except Exception as exc:
        print(f"error: export failed – {exc}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
